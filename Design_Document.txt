==================================
Design Philosophy for this project
==================================


In this project I have implemented a Mandelbrot Fractal viewer and animator. Some of the features I have implemented are:

1. Zooming in and out (Here the fractal can be zoomed in or out by large amounts like e-7/e+9, which are basically the limits of the data types used) : This was a basic requirement presented in the project which was achieved within the pre-submission deadline itself. The way in which this was done is that we defined a method in our "MANDELBROT CLASS" (which contains all the coloring algorithms, methods and utilities that have been implemented in this project), and that method accepted generic arguments, and consequently, every time we zoom in or out, just the parameters for some coordinate geometry equations change, and a new image is formed (the old image doesn't persist, and thus we feel as if the image has zoomed, whereas in reality it has just been replaced by the zoomed image very fast).

Coming to the our updateImageSlice method, since it constructs a Mandelbrot fractal with a very general set of coordinates and zoom parameters, it is an ideal candidate for threading and parallel execution. Indeed, we have used MULTI-THREADING (2 threads) to simultaneously update 2 parts of the image, thus improving speed. 

Also, we implemented a COMPLEX CLASS and overloaded the standard arithmetic operators to allow for almost mathematical expressions of the complex equations needed for implementing the Mandelbrot fractal. 

2. Up, Down, Right and Left (these basically move the fractal up, down, right and left on receiving the corresponding key presses from the keyboard): Their implementations are more or less similar to zoom in and zoom out, and just involve some coordinate geometry details involving "OFFSET FACTORS"

3. Screenshot (This enables the user to take a screen shot of the present state by pressing the S button on the keyboard): The implementation from the SFML side was very smooth, except for one hiccup: We need to supply a file name to it, and supplying a constant string as file name would lead to overwriting of the same file. Thus we need a dynamic string container (as in a constant string appended by the time at which the screen shot was taken, which is guaranteed to be unique. We also need a dynamic string container to dynamically update the title bar of the window in SFML with current zoom levels) (we DID NOT USE std::string), which we implemented in the myString class, which allows for deque like behavior (needed to strip away extra qualifiers generated by std::chrono), as well string appending, copying, assignment, string_length and the likes. Thus we successfully implemented and used the STRING DATA STRUCTURE.

4. Coloring algorithms: We have mainly implemented 2 classes of coloring algorithms:
The first class of algorithms calculate the number of iterations needed for a complex number to diverge, and depending on whether the number of Iterations lies in [0, 16), [16, 32), [32, 64) and [64, 127) or <= 127 the point (pixel) is assigned a color (Red/ Blue/ Green/ Red/ Black).
In our exp-res algorithm, we have implemented an exponential interpolation algorithm which makes extensive use of our custom defined myVector CLASS (which is dynamically grow-able and templated, making it almost equivalent to the STL version), in which insertion, insertion at rank, pop_back, size methods, [] operator overloads and overloads of standard arithmetic operators have been performed.
Thus, we utilized the VECTOR DATA STRUCTURE also.

For our second class of algorithms, instead of defining color charts as above, we defined color gradients, and depending on the number of iterations taken to diverge, the color of that pixel was made more and more intense, creating a gradient view. Random numbers were used to generate "smoky" views, and non zero initial RGB gradients were used to create green-screen like monochrome gradients also. 
Finally, we also used the STACK data structure: Every key press which led to some reversible action (=,-,U,D,L,R) was appended to a stack, and the Z key press unrolled the stack and undid the actions carried out by the users. We thus implemented the stack data structure on our own, borrowing from the vector class, but keeping some crucial methods out (such as access at any rank in a vector is allowed, but not in stacks), respecting the axioms of the stack data structure.


Thus, these were some of the classes, data structures and features we used and implemented.
For exact details feel free to go through main.cpp.
As mentioned by sir, my line count including all my code files is ~1100	, which matches with the requirement (1000-1500 lines).














 
